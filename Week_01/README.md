学习笔记

### 第一周总结

1.因为是自学转行的前端程序员，虽然工作已经好几年了，但是算法方面一直是一个很难逾越的门槛。leetcode 从几年前刚开始自学编程的时候就有涉猎，但是到现在也只是刷了十几道题，然后重复的题过一段时间再做，Medium 以上的题基本上就很难做出来了。当时就是很像老师所说的那样，自己不甘心看题解，一定想要自己想出来，然后一道题往往要花上一两个小时。试听课的时候听了这个‘五毒神掌’这个解题方法，有一种茅塞顿开的感觉，而且这种练习方法其实不仅限于算法，语言语法上的一些技术细节也可以靠这个方法去学习。所以当时立刻就报了全套的训练营课程。

2.计算机学科还是一门实践性的科学，基于老师的方法，我做了一个简单的表格，用于跟踪记录做题的次数与重复的日期。第一周算是基本达到了既定目标，希望后面能够坚持 100 天。

![image](https://github.com/wumengchao1989/algorithm014-algorithm014/blob/master/Week_01/ScreenShot.png)

3.学习算法刷题最立竿见影的效果当然是应对大厂的面试，但是在实际工作中我觉得这种基础性的学科还是能拓展自己的思维方式，在看一些框架源码或者底层实现的时候，如果算法数据结构基础扎实，那就相对更自然的会理解源码写法的用意，不然有些时候很难往那方面去想。最近在写一个自动化的前端回归测试软件，里面涉及到不同 DOM 树的遍历和比较，当前的实现效率和准确率还堪忧，觉得自己算法这块如果扎实一点，可能就会有更好或者效率更高的写法。

### 解题记录

## Design Circular Deque

基于双指针数组构建，根据循环队列的特性，要保证数组任何时刻一定至少有一个位置不存放有效元素。在插入和删除的时候指针的索引+1 和-1 是一个需要理解和记忆的地方，容易出错。

## Merge Two Sorted Lists

引入 dummyNode（哨兵）会减少判断边界的复杂度，循环判断 l1，l2 的值。

## Trapping Rain Water

这道题卡了一点时间，看到 hard 有点慌，后来看了一个视频讲解，发现其实主要需要想到一个关键点就是对于单个点来说，只要判断当前节点左边的子序列的最大值和右边子序列的最大值，找出两个最大值中较小的那个，再减去当前点，就可以得出当前点可以容纳的水量。即 f(current)=Math.min(LeftMax,RightMax)-current，最后把所有 current 累加即可得到总数。

写了两种方式，一种暴力法，遍历每个值的左右序列，两层循环，复杂度 O(n^2)，另一种 dp，先分别从左到右和从右到左遍历把每个值的左右最大值存在数组里，然后最后对数组里每个点做通项公式的求和，该方法就避免的暴力法中很多值的重复计算，三个单层循环，复杂度 O(n);

## TwoSum

利用 hashmap，储存数组中每个值的的对应值和当前值的 index，当访问到对应值时返回相应的 index.JS 里，开始直接使用了 if(!map[nums [i]]),结果在 nums[i]=0 的时候导致错误，后来改成了 map[nums[i]] !== undefined。
