学习笔记

### 第一周总结

1.因为是自学转行的前端程序员，虽然工作已经好几年了，但是算法方面一直是一个很难逾越的门槛。leetcode 从几年前刚开始自学编程的时候就有涉猎，但是到现在也只是刷了十几道题，然后重复的题过一段时间再做，Medium 以上的题基本上就很难做出来了。当时就是很像老师所说的那样，自己不甘心看题解，一定想要自己想出来，然后一道题往往要花上一两个小时。试听课的时候听了这个‘五毒神掌’这个解题方法，有一种茅塞顿开的感觉，而且这种练习方法其实不仅限于算法，语言语法上的一些技术细节也可以靠这个方法去学习。所以当时立刻就报了全套的训练营课程。

2.计算机学科还是一门实践性的科学，基于老师的方法，我做了一个简单的表格，用于跟踪记录做题的次数与重复的日期。第一周算是基本达到了既定目标，希望后面能够坚持100天。

![image](https://github.com/wumengchao1989/algorithm014-algorithm014/blob/master/Week_01/ScreenShot.png)

### 解题记录

## Design Circular Deque
基于双指针数组构建，根据循环队列的特性，要保证数组任何时刻一定至少有一个位置不存放有效元素。在插入和删除的时候指针的索引+1和-1是一个需要理解和记忆的地方，容易出错。

## Merge Two Sorted Lists 
引入dummyNode（哨兵）会减少判断边界的复杂度，循环判断l1，l2的值。

## Trapping Rain Water
这道题卡了一点时间，看到hard有点慌，后来看了一个视频讲解，发现其实主要需要想到一个关键点就是对于单个点来说，只要判断当前节点左边的子序列的最大值和右边子序列的最大值，找出两个最大值中较小的那个，再减去当前点，就可以得出当前点可以容纳的水量。即f(current)=Math.min(LeftMax,RightMax)-current，最后把所有current累加即可得到总数。

写了两种方式，一种暴力法，遍历每个值的左右序列，两层循环，复杂度O(n^2)，另一种dp，先分别从左到右和从右到左遍历把每个值的左右最大值存在数组里，然后最后对数组里每个点做通项公式的求和，该方法就避免的暴力法中很多值的重复计算，三个单层循环，复杂度O(n);

## TwoSum
利用hashmap，储存数组中每个值的的对应值和当前值的index，当访问到对应值时返回相应的index.JS里，开始直接使用了if(!map[nums [i]]),结果在nums[i]=0的时候导致错误，后来改成了map[nums[i]] !== undefined。






